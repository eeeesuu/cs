# Operating System
## 운영체제 개요
### 운영체제의 역할과 목적

### 운영체제의 구조
#### 커널 (Kernel Mode)
- 운영체제의 핵심 기능들이 실행되며, 하드웨어 자원에 대한 전체 접근 권한을 가지고 있음.
- 특징:
  - 커널 모드는 CPU의 모든 명령어와 하드웨어 자원에 접근 가능.
  - 사용자 프로세스가 시스템 자원에 침범하는 것을 방지.
- 실행 예시:
  - 프로세스 생성 및 종료.
  - 시스템 호출 처리.
#### 사용자 모드 (User Mode)
- 일반 어플리케이션 프로그램이나 사용자가 실행하는 소프트웨어가 실행되는 모드.
- 특징:
  - 제한된 권한을 가지고 있음.
  - 시스템의 안전성을 보호하기 위한 중요한 역할을 한다. 
- 실행 예시:
  - 웹 브라우저와 같은 응용 프로그램.
  - 사용자 프로그램에 의한 파일 시스템 접근.

### 운영체제의 종류
#### 단일 사용자 (Single-User Operating System)
- 정의: 한 번에 하나의 사용자만 시스템을 사용할 수 있도록 설계된 운영체제.
- 특징:
  - 하나의 사용자만 지원.
  - 다중 사용자 시스템에 비해 관리가 상대적으로 용이.
  - 리소스 충돌이나 다중 사용자 간의 자원 공유 문제를 걱정할 필요가 없다. 
#### 다중 사용자 (Multi-User Operating System)
- 정의: 여러 명의 사용자가 동시에 시스템 자원을 공유하며 사용할 수 있도록 설계된 운영체제.
- 특징:
  - 여러 사용자 지원.
  - 동시에 여러 프로그램을 실행할 수 있는 멀티태스킹 기능을 제공.
  - 사용자별 권한 관리, 자원 접근 제어 등을 통해 보안을 강화. 
#### 분산 OS (Distributed Operating System)
- 정의: 여러 개의 독립적인 컴퓨터나 노드가 네트워크를 통해 상호 연결되어 하나의 통합된 시스템처럼 작동.
- 특징:
  - 자원을 공유할 수 있다.
  - 자원 공유, 위치, 접근 등에 대한 투명성을 제공.
  - 일부 노드가 실패하더라도 전체 시스템이 작동 가능. 
- 장점:
  - 필요에 따라 더 많은 노드를 추가할 수 있음.
  - 시스템의 가용성과 신뢰성이 높다.
- 단점: 
  - 데이터 일관성을 유지하기 위한 동기화 문제가 발생할 수 있음.
  - 보안 취약점 발생 가능.
#### 실시간 OS (Real-Time Operating System, RTOS)
- 정의: 시스템이 주어진 시간 내에 작업을 완료할 수 있도록 보장하는 운영체제.
- 특징:
  - 작업이 완료되는 시간에 대한 엄격한 제한이 있음.
  - 우선순위 기반 스케줄링을 사용.
  - 멀티태스킹을 지원.
- 장점:
  - 시스템이 예측 가능한 방식으로 동작하여 높은 신뢰성을 제공.
  - 응답 시간과 처리 시간을 예측하고 관리할 수 있음.
- 단점: 엄격한 시간 제약을 충족해야 하므로, 설계와 구현이 복잡.
- 저수준의 하드웨어 자원을 많이 소모할 수 있음.

## 프로세스 관리

### 프로세스와 스레드
#### 프로세스 (Process)
- 정의: 
   - 운영체제에서 프로세스는 프로그램 코드와 함께 실행에 필요한 자원을 포함한 독립적인 실행 단위. 
   - 실행 중인 프로그램을 의미하기도 함.
- 구성요소
  1. 프로그램 코드: 실행 중인 명령어들.
  2. 프로세스 상태: 프로세스의 수행 상태를 나타냄.
  3. 프로세스 카운터: 현재 실행 중인 명령어의 주소를 가리키는 포인터.
  4. 레지스터: 프로세스 상태 정보 저장.
  5. 메모리: 프로세스가 사용하는 메모리 공간. 
  6. 파일 디스크립터: 프로세스가 열어놓은 파일들에 대한 정보.
#### 프로세스 상태
1. 준비 상태
   - 설명: 실행을 위해 CPU를 기다리고 있는 상태. 
   - 특징: 실행할 준비는 되었으며, CPU가 할당될 때 실행됨.
2. 실행 상태
   - 설명: CPU에서 실행되고 있는 상태.
   - 특징: CPU를 할당받아 프로그램 코드의 명령을 수행 중.
3. 대기 상태/ 블로킹 상태
   - 설명: 입출력이나 다른 자원을 기다리는 상태.
   - 특징: 주로 입출력 작업이나 외부 이벤트를 기다릴 때 발생하고 자원이 준비되면 준비 상태로 전환.
4. 종료 상태
   - 설명: 실행을 마친 후 종료된 상태.
   - 특징: 정상적으로 종료되거나 오류로 인해 종료되었을 때 이 상태로 돌아감.
#### 스레드 (Thread)
- 정의: 프로세스 내에서 실행되는 작은 작업 단위.
- 특징: 여러 스레드가 동시에 실행되며, 스레드는 프로세스의 자원을 공유하면서 독립적으로 실행.


### CPU 스케즐링
#### 선정형 스케줄링 (Preemptive Scheduling)
- 정의: 프로세스의 실행을 강제로 중단하고 다른 프로세스에게 CPU 자원을 할당하는 방식.
- 특징:
  - 하나의 프로세스가 CPU를 할당받고 실행 중이라도, 다른 프로세스가 높은 우선순위를 가지면 그 프로세스가 CPU를 선점.
  - 스케줄러는 주기적으로 프로세스를 점검하고, 자원 할당을 동적으로 결정.
- 장점:
  - 응답 시간이 빠르다.
  - 자원이 공평하게 분배되어 시스템 자원의 낭비를 줄일 수 있음.
- 단점:
  - 프로세스의 실제 실행 시간 예측이 어려워질 수 있음.
  - 실행 상태를 저장하고 복원하는 데 드는 시간과 자원 비용 발생.
#### 비선정형 스케줄링 (Non-Preemptive Scheduling)
- 정의: 실행 중인 프로세스가 완료되기 전까지 다른 프로세스가 CPU를 강제로 빼앗지 않는 방식.
- 특징:
  - 스케줄링 중간에 프로세스 전환이 없다.
  - 한 프로세스가 CPU를 차지하고 있는 동안 다른 프로세스가 실행되지 않으므로, 주로 프로세스 간의 간섭이 없다. 
1. FCFS (First-Come, First-Served)
   - 가장 먼저 도착한 프로세스를 먼저 실행.
   - 순차적인 실행 보장.
2. SJF (Shortest Job First)
   - 실행 시간이 가장 짧은 프로세스를 먼저 실행.
   - 평균 대기 시간 최소화.
3. 고정 우선순위
   - 우선순위에 따라 프로세스 실행.
- 장점:
  - 강제 중단시키지 않으므로 구현이 간단.
  - 프로세스 에측 가능성이 높다.
- 단점:
  - 다른 프로세스의 대기 시간이 길어질 수 있다(응답 시간 증가 가능).
  - 자원을 효율적 분배하는 데 어려움.
#### 스케줄링 성능 평가

### 동기화 (Synchronization)
- 정의: 여러 프로세스나 스레드가 동시에 실행될 때, 데이터의 무결성을 유지하고 정확한 실행 순서를 보장하기 위한 메커니즘.
#### 임계 구역 문제 (Critical Section Problem)
- 임계 구역: 여러 프로세스가 공유 자원에 접근하고 수정할 수 있는 코드의 영역.
##### 문제 해결 조건
1. 상호 배제
   - 한 프로세스가 임계 구역에서 실행 중일 때, 다른 프로세스는 임계 구역에 접근할 수 없다.
2. 진행 조건
   - 임계 구역에 들어가려는 프로세스가 없을 경우, 임계 구역에 진입할 프로세스를 결정하는 데 불필요한 대기가 없어야 한다. 
3. 한정된 대기 조건
   - 한 프로세스가 임계 구역에 진입하려고 대기하는 동안, 다른 프로세스가 임계 구역에 계속 진입하지 않아야 함.
   - 대기 시간이 유효해야 한다. 
#### 세마포어와 모니터
#### 1. 세마포어
- 정의: 다중 프로세스 또는 스레드 간 동기화를 위해 사용되는 정수형 변수. 
- 세마포어의 종류:
  1. 카운팅 세마포어:
     - 0 이상의 값을 가질 수 있으며, 특정 자원의 최대 접근 가능 수를 관리.
  2. 이진 세마포어:
     - 0 또는 1만 가지는 세마포어로, 뮤텍스와 유사하게 동작.
     - 주로 상호 배제 구현. 
- 세마포어의 주요 연산:
  1. Wait(P 연산):
     - 세마포어 값을 감소시키고, 값이 음수이면 프로세스를 대기 상태로 전환.
     - 자원이 사용 가능한지 확인. 
  2. Signal(V 연산):
     - 세마포어 값을 증가시키고, 대기 중인 프로세스가 있으면 깨워서 실행.
     - 자원의 사용이 끝났음을 알림. 

```c
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>

sem_t semaphore;

void* thread_function(void* arg) {
    sem_wait(&semaphore); // 세마포어 잠금
    printf("Thread %ld is in the critical section\n", pthread_self());
    sem_post(&semaphore); // 세마포어 해제
    return NULL;
}

int main() {
    pthread_t threads[3];
    sem_init(&semaphore, 0, 1); // 이진 세마포어 초기화

    for (int i = 0; i < 3; i++)
        pthread_create(&threads[i], NULL, thread_function, NULL);

    for (int i = 0; i < 3; i++)
        pthread_join(threads[i], NULL);

    sem_destroy(&semaphore);
    return 0;
}
```
#### 2. 모니터
- 정의: 프로세스 간 동기화를 위한 고수준의 동기화 도구.
- 모니터 특징:
  - 모니터 내부에서 하나의 프로세스만 작업을 수행할 수 있도록 보장.
  - wait와 signal 연산을 제공. 

#### 뮤텍스와 조건 변수
#### 1. 뮤텍스 
- 정의: 상호 배제를 보장하기 위해 사용되는 동기화 기법으로, 다중 스레드 환경에서 공유 자원에 대한 동시 접근을 방지. 
- 뮤텍스 특징:
   - 동시에 하나의 스레드만 자원에 접근할 수 있도록 보장.
   - 잠금: 자원을 사용하려는 스레드는 뮤텍스를 잠근다.
   - 래제: 자원 사요이 끝난 스레드는 뮤텍스를 해제하여 다른 스레드가 접근할 수 있도록 함.
   - 뮤텍스는 특정 스레드가 소유하며, 소유한 스레드만 잠금 해제 가능. 
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex; // 뮤텍스 선언

void* thread_function(void* arg) {
    pthread_mutex_lock(&mutex); // 뮤텍스 잠금
    printf("Thread %ld is in the critical section\n", pthread_self());
    pthread_mutex_unlock(&mutex); // 뮤텍스 해제
    return NULL;
}

int main() {
    pthread_t threads[2];
    pthread_mutex_init(&mutex, NULL); // 뮤텍스 초기화

    for (int i = 0; i < 2; i++) {
        pthread_create(&threads[i], NULL, thread_function, NULL);
    }

    for (int i = 0; i < 2; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&mutex); // 뮤텍스 제거
    return 0;
}
```
#### 2. 조건 변수 
- 역할: 특정 조건이 만족될 때까지 스레드를 대기 상태로 만들거나, 조건이 충족되었을 때 대기 중인 스레드를 깨우는 역할.
- 특징:
  - 조건 기반 동기화.
  - wait: 조건이 충족될 때까지 스레드를 대기 상태로 만든다.
  - signal 또는 broadcast: 조건이 충족되었음을 알리고 대기 중인 스레드를 깨운다.
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex;
pthread_cond_t cond; // 조건 변수 선언
int ready = 0;

void* producer(void* arg) {
    pthread_mutex_lock(&mutex);
    ready = 1; // 조건 변경
    printf("Producer: Condition is met, signaling...\n");
    pthread_cond_signal(&cond); // 조건 변수 신호 보내기
    pthread_mutex_unlock(&mutex);
    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    while (!ready) {
        printf("Consumer: Waiting for condition...\n");
        pthread_cond_wait(&cond, &mutex); // 조건 변수 대기
    }
    printf("Consumer: Condition met, proceeding...\n");
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    pthread_create(&t1, NULL, producer, NULL);
    pthread_create(&t2, NULL, consumer, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    return 0;
}

```
### 교착상태 (Deadlock)
- 정의: 둘 이상의 프로세스가 서로 자원을 점유한 상태에서, 필요한 자원을 얻기 위해 서로 대기하다가 영원히 진행될 수 없는 상태.
#### 교착상태의 조건
1. 상호 배제
   - 자원은 한 번에 하나의 프로세스만 사용 가능.
   - 자원은 배타적으로 접근.
2. 점유와 대기
   - 최소 하나의 자원을 점유한 상태에서 다른 자원을 요청하며 대기하는 프로세스 존재.
3. 비선점
   - 자원을 점유한 프로세스는 스스로 자원을 해제하기 전까지 강제로 빼앗길 수 없다.
4. 순환 대기 
   - 둘 이상의 프로세스가 원형으로 연결되어 각 프로세스가 다음 프로세스가 점유한 자원을 대기.
#### 교착상태 해결 방법
1. 예방
   - 교착 상태 발생 조건 중 하나를 제거해 발생 가능성을 원천으로 차단. 
2. 회피
   - 시스템 상태를 실시간으로 분석하여 안전 상태에서만 자원을 할당. 
3. 탐지와 복구
   - 탐지:
     - 자원 할당 그래프: 프로세스와 자원 간의 할당과 요청 상태를 나타내는 그래프로 순환 대기가 발견되면 교착 상태로 간주.
     - 탐지 주기를설정해 정기적으로 교착 상태를 감지.
   - 복구:
     - 교착 상태에 관여하는 하나 이상의 프로세스를 강제로 종료.
     - 점유 중인 자원을 강제로 회수. 
4. 무시 
   - 교착 상태가 발생할 확률이 낮은 경우, 교착 상태 관리 메커니즘을 구현하지 않고 발생 시 시스템을 재시작하는 방식. 

## 메모리 관리
### 메모리 계층 구조
- 정의: 메모리 장치들이 성능과 비용을 기준으로 계층적으로 구성된 구조. 
- 구성
  1. 레지스터
    - 프로세서 내부에 위치한 초고속 메모리.
  2. 캐시 메모리
    - 주기억장치와 CPU 사이에 위치.
  3. 주기억장치
    - 실행 중인 프로세스와 데이터를 저장. 
  4. 보조 기억 장치
    - 데이터를 영구적으로 저장하는 장치.
  5. 원격 보조 기억 장치
    - 클라우드 스토리지나 외부 저장 장치 등으로, 주로 데이터 백업이나 아카이빙에 사용. 
---이미지삽입하기 
### 주기억장치 관리 (Main Memory Management)
#### 단순 관리- 고정 분할, 가변 분할
#### 1. 고정 분할
- 정의: 주기억장치를 고정된 크기의 블록으로 나누는 방식.
- 특징: 
  - 블록 크기는 시스템 초기화 시 결정되며 변경되지 않음.
  - 프로세스는 자신의 크기보다 크거나 같은 블록에 할당됨. 
  - 내부 단편화: 프로세스 크기가 블록보다 작을 경우, 사용하지 않는 공간이 발생.
  - 외부 단편화 없음: 블록 간의 빈 공간 없음.
- 장점: 블록 크기가 고정되어 메모리 할당과 해제가 간단.
- 단점: 내부 단편화로 메모리 낭비 발생. 
#### 2. 가변 분할 
- 정의: 주기억장치를 프로세스 크기에 따라 동적으로 분할하여 할당하는 방식. 
- 특징:
  - 프로세스 크기에 맞게 메모리 블록의 크기가 동적으로 결정됨.
  - 빈 공간 중 프로세스 크기 맞는 곳에 메모리 할당.
  - 외부 단편화: 메모리 사이에 사용하지 못하는 작은 빈 공간이 발생.
  - 내부 단편화 없음. 
- 장점: 메모리 사용이 효율적.
- 단점: 할당과 해제를 반복하면서 작은 빈 공간이 늘어남. 
#### 페이징과 세그멘테이션
#### 1. 페이징
- 정의: 주기억장치를 고정 크기의 페이지라는 단위로 나누고, 그 페이지 단위로 분할하여 메모리 할당을 관리하는 기법.
- 특징:
  - 논리 주소 공간은 페이지로 나누어지고, 물리 주소 공간(실제 메모리)은 페이지 프레임으로 나눠져 있음. 
  - 내부 단편화와 외부 단편화가 없음.
  - 논리 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용.
- 장점: 메모리 자원을 효율적으로 사용.
- 단점: 페이지 테이블 저장, 관리로 인한 메모리와 시간적인 오버헤드 발생 가능. 
#### 2. 세그멘테이션 
- 정의: 프로세스를 논리적인 단위로 나누어 메모리를 할당하는 방식. 
- 특징:
  - 세그먼트의 크기는 가변적이다. 
  - 작은 빈 공간들이 발생할 수 있으며, 외부 단편화 문제 발생 가능. 
  - 세그먼트 번호와 오프셋으로 구성된 주소를 물리 주소로 변환하려면 세그먼트 테이블을 사용. 
- 장점: 세그먼트 크기가 동적이기 때문에 필요에 따라 크기 조정 가능. 
- 단점: 세그먼트 크기가 다르기 때문에 빈 공간들이 발생할 수 있다.
#### 페이징과 세그멘테이션의 조합
- 세그먼트 단위로 프로그램을 나누고, 각 세그먼트 내부는 페이징으로 나누는 방식. 
- 조합 방식:
  1. 세그멘테이션:
     - 프로그램을 세그먼트라는 논리적 단위로 분할. 
     - 각 세그먼트는 크기가 다를 수 있으며, 세그먼트 크기와 위치는 동적으로 할당.
  2. 페이징:
     - 각 세그먼트는 다시 페이지라는 고정 크기의 단위로 나누어짐.
     - 각 페이지는 고정된 크기로 메모리 할당됨.
- 주소 변환 과정:
  1. 논리 주소에서 세그먼트 번호 추출.
  2. 세그먼트 번호를 사용하여 세그먼트 테이블을 참조하고, 세그먼트의 시작주소와 크기 확인.
  3. 세그먼트 내에서 주소의 일부를 페이지 번호로 변환.
  4. 페이지 번호를 사용하여 해당 페이지의 물리적 주소를 찾음. 
  5. 세그먼트 또는 페이지 내의 오프셋을 사용하여 최종 물리 주소를 계산. 
- 장점:
  - 세그먼트 크기가 다르더라도 외부 단편화 문제를 줄일 수 있음.
  - 페이징을 통해 메모리 효율성을 높임. 
- 단점: 
  - 주소 변환 과정에서 두 단계의 변환이 필요하여 시간적인 비용이 발생 가능. 
  - 두 가지 테이블 관리로 인해 추가적인 오버헤드 발생 가능. 
### 가상 메모리 (Virtual Memory)
- 정의: 실제 물리적 메모리의 크기보다 더 큰 메모리 공간을 프로그램에 제공하는 기법. 
- 특징: 
  - 가상 메모리는 물리적 메모리와 독립적이다.
  - 가상 주소를 물리 주소로 변환하는 과정이 필요하다.
  - 가상 메모리는 물리 메모리의 크기에 제한되지 않는다. 
#### 페이지 교체 알고리즘 (Page Replacement Algorithms)
- 정의: 가상 메모리 시스템에서 페이지 폴트가 발생할 때, 메모리에서 어떤 페이지를 교체할지 결정하는 방법. 
#### 1. FIFO (First In, First Out)
- 원리: 메모리에 들어온 순서대로 페이지를 교체.
- 동작:
  - 새로운 페이지가 들어올 때마다, 가장 오래된 페이지를 찾아서 교체.
  - 큐를 사용하여 페이지가 메모리에 들어온 순서를 추적.
- 장점: 구현이 간단하고 직관적.
- 단점: 페이지 교체가 비효율적일 수 있음. 
#### 2. LRU (Least Recently Used)
- 원리: 가장 오랫동안 사용되지 않은 페이지를 교체.
- 동작:
  - 각 페이지가 마지막으로 참조된 시간을 기록.
  - 새로운 페이지가 들어오면, 가장 오래 전에 참조된 페이지를 교체. 
- 장점: 실제 프로그램의 사용 패턴과 더 일치하는 방식, 효율적임. 
- 단점: 시간을 추적하는 데 많은 자원이 필요함. 
#### 3. LFU (Least Frequently Used)
- 원라: 가장 적게 사용된 페이지를 교체.
- 동작:
  - 각 페이지의 사용 빈도를 카운팅.
  - 새로운 페이지가 들어올 때, 사용 횟수가 가장 적은 페이지를 교체.
- 장점: 효율적인 메모리 관리 가능. 
- 단점: 사용 횟수 추적해야 하기 때문에 추가적인 메모리와 연산 필요. 
#### 스왑 공간 관리 (Swap Space Management)
- 정의: 주기억장치가 부족할 때 디스크의 일부 영역을 가상 메모리처럼 사용하는 방식.
- 특징:
  - 스왑 공간의 크기는 동적으로 조정될 수 있다.
  - 스왑 공간은 스왑 파티션과 스왑 파일로 구분. 
    - 스왑 파티션은 디스크의 별도 영역을 파티션으로 나누어 그 곳을 스왑 공간으로 사용하는 방식. 
    - 스왑 파일은 디스크 상의 파일로 스왑 공간을 구성하는 방식. 
- 장점:
  - 물리적 메모리 확장.
  - 멀티태스킹 지원.
- 단점: 
  - 디스크는 RAM에 비해 훨씬 느리기 때문에, 스왑 공간을 자주 사용하면 시스템 성능이 저하됨.
  - 디스크 용량이 부족해질 수 있음. 

----이미지 삽입하기 

## 파일 시스템
### 파일의 개념과 구조
#### 파일
- 정의: 컴퓨터에서 데이터를 저장하고 관리하는 기본 단위. 
- 파일 이름: 파일을 식별하는데 사용.
- 파일 경로: 특정 디렉토리나 폴더에 위치하며, 경로를 사용하여 파일에 접근.
- 파일 타입: 내용에 따라 여러 타입으로 분류 가능. 
### 디렉토리 구조
#### 디렉토리 
- 정의: 파일이나 다른 디렉토리를 조직적으로 관리하는데 사용되는 공간.
#### 단일 레벨, 다중 레벨, 트리 구조
#### 1. 단일 레벨
- 구조:
  - 하나의 디렉토리만 존재하며, 그 안에 모든 파일이 저장됨. 
- 장점: 구현이 간단하고 관리가 쉬움
- 단점: 파일 이름 충돌 가능성이 큼.
#### 2. 다중 레벨
- 구조:
  - 상위 디렉토리가 있고, 그 안에 여러 개의 하위 디렉토리 존재.
  - 각 하위 디렉토리에는 파일이 저장됨.
- 장점: 파일을 그룹화하여 관리할 수 있어 조직적.
- 단점: 상위, 하위 디렉토리 구조를 관리해야 하므로 관리 복잡. 
#### 3. 트리 구조
- 구조:
  - 루트 디렉토리에서 시작하여 여러 개의 하위 디렉토리가 있으며, 각 하위 디렉토리에도 또 다른 하위 디렉토리가 있을 수 있음.
  - 각 하위 디렉토리에는 파일이 저장됨.
  - 부모 디렉토리와 자식 디렉토리의 관계가 명확하게 설정됨.
- 장점: 파일을 효율적으로 검색하고 접근할 수 있음. 
- 단점: 트리 구조가 깊어지면 탐색 속도 느려질 수 있음. 
----각 레벨에 따른 이미지 삽입 
### 파일 할당 방법
#### 연속 할당, 연결 할당, 색인 할당
#### 1. 연속 할당
- 구조:
  - 파일이 디스크 상에 연속된 공간에 할당됨.
- 장점: 연속된 블록에 저장되므로 접근 속도가 빠르다. 
- 단점: 파일의 크기가 커지거나 작아지면 연속된 공간을 찾기 어렵다. 
#### 2. 연결 할당
- 구조: 
  - 각 파일 블록이 링크된 리스트 형태로 구성됨. 
  - 각 블록은 데이터와 다음 블록을 가리키는 포인터를 가짐.
- 장점: 비연속적으로 저장되어도 링크를 통해 연결되어 외부 단편화 문제를 피함. 
- 단점: 포인터를 저장하는 데 추가적인 공간 필요.
#### 3. 색인 할당 
- 구조:
  - 파일에 대해 색인 블록이 존재하며, 색인 블록에는 파일의 모든 데이터 블록 주소가 저장됨. 
- 장점: 
  - 랜덤 접근이 가능하므로 빠르게 접근이 가능.
  - 파일 크기의 동적 관리가 용이하며, 크기가 변경되어도 색인 블록만 수정하면 된다. 
- 단점: 
  - 색인 테이블을 저장하기 위한 추가적인 공간이 필요하다. 
  - 색인 블록을 읽고 데이터 블록을 찾아야 하므로 두 번의 디스크 접근이 필요할 수 있다. 


### 파일 시스템 구현
- 파일 시스템: 운영체제에서 파일을 관리하는 방법을 정의함. 
- 구성 요소:
  1. 파일 제어 블록
     - 파일에 대한 메타데이터를 저장하는 구조체. 
  2. 디렉토리 구조
     - 파일을 논리적으로 조직하는 방식. 
  3. 디스크 블록
     - 파일의 실제 데이터는 디스크 상의 블록에 저장. 
#### 디스크 스케줄링 알고리즘
#### 1. FCFS
- 정의: 요청이 들어온 순서대로 디스크 작업 처리.
- 특징:
  - 가장 간단한 알고리즘.
  - 헤드 이동이 많아질 수 있음.
- 예시
```c
#include <stdio.h>

void FCFS(int arr[], int n, int head) {
    int seek_count = 0;
    int distance, cur_head;

    cur_head = head;
    printf("FCFS Disk Scheduling: \n");

    for (int i = 0; i < n; i++) {
        distance = abs(arr[i] - cur_head);
        seek_count += distance;
        cur_head = arr[i];
        printf("Move from %d to %d, Distance = %d\n", cur_head, arr[i], distance);
    }

    printf("Total seek count: %d\n", seek_count);
}

int main() {
    int arr[] = {98, 183, 41, 122, 14, 124, 65, 67};
    int head = 53;
    int n = sizeof(arr) / sizeof(arr[0]);

    FCFS(arr, n, head);
    return 0;
}

```
#### 2. SSTF
- 정의: 현재 디스크 헤드 위치에서 가장 가까운 요청을 먼저 처리하는 알고리즘. 
- 특징:
  - 디스크 헤드가 가장 가까운 트랙을 우선 처리.
  - 헤드 이동이 최소화됨. 
- 예시
```c
#include <stdio.h>
#include <stdlib.h>

void SSTF(int arr[], int n, int head) {
    int seek_count = 0;
    int distance, cur_head, min_distance, index;
    int visited[n];

    for (int i = 0; i < n; i++)
        visited[i] = 0;

    cur_head = head;
    printf("SSTF Disk Scheduling: \n");

    for (int i = 0; i < n; i++) {
        min_distance = 10000;  // Large number
        index = -1;
        for (int j = 0; j < n; j++) {
            if (!visited[j]) {
                distance = abs(arr[j] - cur_head);
                if (distance < min_distance) {
                    min_distance = distance;
                    index = j;
                }
            }
        }

        visited[index] = 1;
        seek_count += min_distance;
        cur_head = arr[index];
        printf("Move from %d to %d, Distance = %d\n", cur_head, arr[index], min_distance);
    }

    printf("Total seek count: %d\n", seek_count);
}

int main() {
    int arr[] = {98, 183, 41, 122, 14, 124, 65, 67};
    int head = 53;
    int n = sizeof(arr) / sizeof(arr[0]);

    SSTF(arr, n, head);
    return 0;
}

```
#### 3. SCAN
- 정의: 디스크 헤드가 한 방향으로 이동하면서 요청을 처리하고, 끝에 도달하면 반대 방향으로 이동하며 다시 요청을 처리. 
- 특징:
  - 헤드의 이동 거리가 비교적 일정. 
  - 불균형하게 분포된 요청을 처리하는 데 유리. 
- 예시
```c
#include <stdio.h>
#include <stdlib.h>

void SCAN(int arr[], int n, int head, int disk_size) {
    int seek_count = 0;
    int distance, cur_head;
    int left = 0, right = 0;

    cur_head = head;
    printf("SCAN Disk Scheduling: \n");

    for (int i = 0; i < n; i++) {
        if (arr[i] < head)
            left++;
        else
            right++;
    }

    // Sort the requests
    int left_arr[left], right_arr[right];
    int j = 0, k = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] < head)
            left_arr[j++] = arr[i];
        else
            right_arr[k++] = arr[i];
    }

    // Sort the left and right arrays
    for (int i = 0; i < left - 1; i++) {
        for (int j = i + 1; j < left; j++) {
            if (left_arr[i] < left_arr[j]) {
                int temp = left_arr[i];
                left_arr[i] = left_arr[j];
                left_arr[j] = temp;
            }
        }
    }

    for (int i = 0; i < right - 1; i++) {
        for (int j = i + 1; j < right; j++) {
            if (right_arr[i] > right_arr[j]) {
                int temp = right_arr[i];
                right_arr[i] = right_arr[j];
                right_arr[j] = temp;
            }
        }
    }

    // Process the left part
    for (int i = 0; i < left; i++) {
        distance = abs(left_arr[i] - cur_head);
        seek_count += distance;
        cur_head = left_arr[i];
        printf("Move from %d to %d, Distance = %d\n", cur_head, left_arr[i], distance);
    }

    // Process the right part
    for (int i = 0; i < right; i++) {
        distance = abs(right_arr[i] - cur_head);
        seek_count += distance;
        cur_head = right_arr[i];
        printf("Move from %d to %d, Distance = %d\n", cur_head, right_arr[i], distance);
    }

    printf("Total seek count: %d\n", seek_count);
}

int main() {
    int arr[] = {98, 183, 41, 122, 14, 124, 65, 67};
    int head = 53;
    int disk_size = 200;
    int n = sizeof(arr) / sizeof(arr[0]);

    SCAN(arr, n, head, disk_size);
    return 0;
}

```
#### 파일 시스템 무결성 
#### 1. 저널링
- 정의: 파일 시스템에서 데이터와 메타데이터 변경을 추적하는 방법.
- 특징:
  - 데이터를 수정하거나 추가할 때, 실제 파일 시스템에 쓰기 전에 저널이라는 별도의 로그에 변경 내용을 먼저 기록. 
- 장점: 
  - 저널에 기록된 내용을 이용해 빠르게 복구 가능. 
  - 데이터 손상이나 파일 시스템의 불일치 방지. 
- 단점: 
  - 저널에 모든 변경 사항을 기록하므로, 저널 파일의 크기가 커질 수 있음. 
  - 시스템의 복잡성을 증가시킬 수 있다. 
#### 2. RAID
- 정의: 여러 개의 하드 디스크를 결합하여 성능을 향상시키거나 데이터를 안전하게 보호하는 기술. 
- 특징:
  - 데이터 손실 방지.
  - 여러 개의 디스크를 병렬로 사용하여 데이터를 분할하고 동시에 읽고 쓸 수 있음. 
- 장점: 데이터 복구할 수 있는 방법 제공. 
- 단점: 여러 개의 하드 드라이브를 필요로 하기 때문에 초기 설치 비용이 증가. 


## 입출력 관리
### I/O 하드웨어와 소프트웨어
---이미지 삽입
#### 1. I/O 하드웨어
- 정의: 시스템의 외부 장치와 직접 상호 작용하는 물리적 장치. 
- 입력 장치, 출력 장치, 저장 장치, 네트워크 장치 등이 있음. 
#### 2. I/O 소프트웨어
- 정의: I/O 하드웨어와의 상호 작용을 제어하고 관리. 
- 운영체제, 장치 드라이버, I/O 제어 프로그램 등이 있다. 
### 장치 드라이버의 역할
- 장치 드라이버: 운영체제와 하드웨어 장치 간의 중재 역할을 함. 
- 역할:
  - 하드웨어와 운영체제 간의 인터페이스 제공.
  - 하드웨어 추상화.
  - 입출력 작업 처리.
### 인터럽트와 폴링
#### 1. 인터럽트
- 정의: 하드웨어나 소프트웨어가 CPU에게 현재 진행 중인 작업을 잠시 중단하고 특정 작업을 처리하라고 요청하는 방식.
- 특징:
  - 비동기적 방식이다. 
  - CPU 간섭.
- 동작:
  - 하드웨어 장치가 완료된 작업을 CPU에 알린다.
  - CPU는 현재 작업을 잠시 중단하고, 인터럽트 서비스 루틴을 실행하여 요청된 작업 처리.
  - 처리 후 CPU는 이전 작업을 계속함. 
- 장점: CPU 자원 절약 가능. 
- 단점: 인터럽트가 빈번히 발생하면, 처리 시간이 많아지고 시스템 효율성이 떨어질 수 있다. 
#### 2. 폴링
- 정의: CPU가 일정한 주기로 하드웨어 장치의 상태를 확인하고, 장치가 준비된 경우 작업을 처리하는 방식.
- 특징:
  - 동기적 방식.
  - 지속적인 체크.
- 동작:
  - CPU는 일정 주기로 하드웨어 장치의 상태 확인.
  - 장치가 준비되면 해당 작업 처리.
  - 작업이 끝나면 다시 장치의 상태를 확인. 
- 장점: 장치의 상태를 쉽게 파악하고 처리할 수 있음.
- 단점: 자원을 비효율적으로 사용할 수 있음. 
### DMA (Direct Memory Access)
- 정의: CPU 개입 없이 외부 장치와 메모리 간에 데이터를 직접 전송하는 방법.
- 특징:
  - CPU 개입 없이 이루어짐. 
  - 데이터가 직접적으로 전송됨.
- 동작:
  1. DMA를 사용하는 장치는 데이터 전송을 요청.
  2. DMA 컨트롤러는 데이터를 메모리에서 장치 또는 그 반대로 직접 전송한다. 
  3. DMA 컨트롤러는 데이터를 전송한 후 CPU에 인터럽트를 발생시켜 데이터 전송이 완료되었음을 알림.
- 장점: 전송 속도가 빠르다.
- 단점: DMA가 데이터 전송을 위해 버스를 사용하기 때문에, 다른 장치와 버스를 공유하는 경우 버스 충돌이 발생할 수도 있음. 
## 운영체제의 보안
### 사용자 인증
- 방식
  1. 비밀번호 기반 인증
     - 가장 널리 사용됨.
  2. OTP
     - 일회용 비밀번호를 생성하여 인증. 
  3. 생체 인증
     - 사용자의 생체 정보를 확인. 

### 접근 제어
- 사용자의 접근을 제어하는 보안 기술. 
#### 접근 제어 모델
1. 임의 접근 제어
   - 리소스의 소유자가 접근 권한을 제어.
   - 파일 소유자가 읽기, 쓰기, 실행 권한을 설정.
2. 강제 접근 제어
   - 시스템이 중앙에서 권한을 관리하며 사용자는 변경 불가능.
   - 민감도 레벨로 접근 권한 설정.
3. 역할 기반 접근 제어
   - 사용자의 역할에 따라 권한을 부여.
   - 예: 관리자, 사용자, 손님.
### 암호화 및 데이터 보호
#### 암호화
- 정의: 데이터를 읽을 수 없는 형식으로 변환하여 정보의 기밀성을 보장. 
- 방식:
  1. 대칭 암호화
     - 하나의 키를 사용하여 데이터를 암호화 및 복호화.
  2. 비대칭 암호화
     - 공개 키와 개인 키를 사용.
  3. 해시 함수
     - 입력값을 고정된 크기의 해시값으로 변환. 
### 보안 정책과 공격 방지 기법
1. 방화벽
   - 외부 네트워크와 내부 네트워크 사이에 보안 장벽 설정.
   - 트래픽 필터링 및 승인된 통신만 허용.
2. 침입 탐지 및 방지 시스템
   - 네트워크 트래픽 모니터링 및 의심스러운 활동 탐지.
   - 침입 시도 시 자동으로 차단.
3. 다단계 인증
   - 사용자 인증 시 비밀번호 외에 추가적인 인증 단계 적용.


## 분산 및 병렬 처리
### 분산 시스템의 개념과 특성
#### 분산 시스템
- 정의: 하나의 작업이 네트워크를 통해 연결된 여러 컴퓨터에서 협력적으로 수행되는 시스템. 
- 특성:
  - 자원 공유.
  - 병렬 처리.
  - 사용자에게 단일 시스템처럼 보이도록 설계됨.
- 장점: 
  - 자원과 노드를 쉽게 추가 가능.
  - 한 노드가 고장 나도 전체 시스템은 작동 가능.
- 단점: 
  - 구현, 유지보수가 어려움.
  - 데이터 일관성 우지가 어려움. 
### 클러스터링 및 로드 밸런싱
#### 클러스터링
- 정의: 여러 대의 컴퓨터(노드)를 하나의 그룹으로 묶어, 사용자에게 단일 시스템처럼 보이도록 구성하는 기술. 
- 특징:
  - 하나의 노드가 고장 나도 시스템의 지속적인 가동을 보장. 
  - 병렬 처리.
  - 클러스터 내에서 작업을 여러 노드로 분산 처리하여 성능 향상. 

#### 로드 밸런싱
- 정의: 여러 서버나 노드 간에 작업 부하를 균등하게 분배하여 성능과 안정성을 향상시키는 기술. 
- 특징:
  - 클라이언트 요청을 고르게 배분하여 병목 현상 방지.
  - 처리량과 응답 속도 향상.
  - 서비스 가동 시간이 늘어남. 
### 병렬 처리와 병렬 컴퓨팅
#### 병렬 처리의 특징
1. 동시성
   - 작업을 동시에 처리함으로써 실행 시간 단축.
2. 태스크 분할
   - 큰 작업을 여러 소작업으로 나누어 병렬로 처리.
3. 고성능
   - 처리 속도가 단일 프로세서에서의 처리보다 훨씬 빠름. 
- 장점: 실행 시간 단축.
- 단점: 스레드 간 동기화 문제.
#### 병렬 컴퓨팅
1. 공유 메모리 모델
   - 모든 프로세서가 동일한 메모리 공간을 공유.
   - 장점: 메모리 접근이 빠름.
   - 단점: 메모리 충돌 가능성이 높음.
2. 분산 메모리 모델
   - 각 프로세서가 독립적인 메모리를 가짐.
   - 장점: 확장성이 높음. 
   - 단점: 데이터 교환이 필요함. 
3. 하이브리드 모델 
   - 공유 및 분산 메모리 모델의 조합. 
### 동기화와 일관성 유지 
- 정의: 여러 노드와 프로세스 간에 작업을 조정하고, 공유 자원에 대한 접근을 관리하는 과정을 의미. 
- 특징: 
  - 여러 프로세스가 동시에 공유 자원에 접근하지 못함.
  - 여러 노드가 다른 시간을 가질 수 있기 때문에, 조정하여 일관된 상태를 유지. 
- 장점: 데이터 일관성과 시스템 안정성 보장. 
- 단점: 일관성 유지를 위한 동기화 작업이 필요함. 