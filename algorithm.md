# Algorithm
## 정렬 (Sorting)
데이터를 일정한 순서대로 나열하는 과정.
### 기본 정렬 알고리즘 

#### (1) 버블 정렬
- 인접한 두 원소를 비교하여, 잘못된 순서라면 교환. 이 과정을 배열의 끝까지 반복하면서, 가장 큰 값이 맨 뒤로 버블처럼 올라간다. 

#### (2) 선택 정렬
- 배열에서 가장 작은 원소를 찾아 맨 앞의 원소와 교환하는 방식으로 정렬한다. 이를 배열 끝까지 반복.
#### (3) 삽입 정렬 
- 두 부분으로 나눈 배열을 생각하면서, 두 번째 부분부터 하나씩 첫 번째 부분에 삽입하는 방식. 
### 고급 정렬 알고리즘
#### (1) 병합 정렬
- 배열을 재귀적으로 반으로 나누고, 나눈 배열을 다시 정렬하여 합치고 중간 단계에서 배열을 두 개의 부분으로 나눈 후, 두 부분을 병합하여 하나의 정렬된 배열을 만든다. 
- 시간 복잡도: O(n log n)
- 공간 복잡도: O(n)
   1. 분할: 입력 배열을 두 개의 하위 배열로 나눈다.
   2. 크기가 1인 배열은 이미 정렬된 상태로 간주하고, 두 개의 배열을 병합하면서 정렬한다.
   3. 병합 과정에서 두 하위 배열을 비교하여 정렬된 배열을 생성한다. 

#### (2) 퀵 정렬
- 중간 원소를 기준으로 배열을 나눈 후, 각 부분을 독립적으로 정렬. 배열을 피벗 기준으로 두 부분으로 나누고, 이를 재귀적 정렬. 
- 시간 복잡도: 평균-O/ 최악-O(N^2)
- 공간 복잡도: O(log n)
   1. 기준 요소(Pivot) 선택: 
     - 하나의 요소를 피봇으로 선택.
   2. 분할:
     - 피벗보다 작은 요소들을 왼쪽에, 피벗보다 큰 요소들을 오른쪽에 위치시킨다. 이 과정을 파티션이라 함.
   3. 정복:
     - 분할된 두 개의 하위 배열에 대해 재귀적으로 퀵 정렬을 수행.
 
#### (3) 힙 정렬
- 완전 이진 트리를 기반으로 한 정렬 알고리즘으로 힙 자료구조를 사용.
- 시간 복잡도 O(n log n)

동작원리 
1. 힙 구성:
   - 주어진 배열을 최대 힙으로 변환.
   - 부모 노드의 값이 항상 자식 노드보다 크도록 재구성.
2. 정렬:
   - 루드 노드를 배열의 끝으로 이동시킨다.
   - 남은 배열에서 다시 최대 힙을 구성하고 반복.

#### (4) 기수 정렬
- 각 자릿수에 대해 순차적으로 정렬을 수행하는 방식.
- 가장 낮은 자리수부터 높은 자리수로 정렬.
- 시간 복잡도: O(d⋅(n+k))

- 장점: 비교 연산 없이 정렬 가능.

- 단점: 입력 데이터의 크기가 크면 메모리 사용량 증가.

#### (5) 계수 정렬
- 주어진 배열에서 특정 값들이 등장한 횟수를 세고, 그 횟수를 바탕으로 정렬된 배열을 만든다. 
- 시간 복잡도: O(n+k) / 공간 복잡도: O(k)

- 동작원리
  1. 데이터의 최솟값과 최댓값을 확인하여 배열의 크기를 결정.
  2. 데이터 값의 개수를 세어 빈도 배열에 저장.
  3. 빈도 배열을 통해 각 데이터 값이 정렬된 배열에서 차지할 위치를 계산.
  4. 원본 배열을 순회하며 각 값을 빈도 배열에 따라 올바른 위치에 배치.

- 장점: 간격을 줄이면서 정렬하므로 삽입 정렬보다 효율적.

- 단점: O(n^2) 수준의 성능 한계가 있음.

#### (6) 셀 정렬 
- 데이터의 특정 간격만큼 떨어진 요소를 비교하고 정렬하며, 점진적으로 간격을 줄여가면서 전체 데이터를 정렬.


- 동작 원리:
  1. 초기 간격 설정
  2. 부분 리스트 정렬:
     - 각 간격에 따라 떨어진 요소를 묶어 부분 리스트를 생성.
     - 각 부분 리스트에 대해 삽입 정렬 수행.
  3. 간격 축소:
     - 간격을 점진적으로 줄여가며 정렬을 반복.
     - 최종적으로 간격이 1일 때 일반적인 삽입 정렬 수행.


## 탐색
데이터 구조 내에서 특정 데이터를 찾거나 확인하는 과정. 
### 기본 탐색 알고리즘 
#### 1. 선형 탐색
- 정의: 처음부터 끝까지 순차적으로 확인하는 방법.
- 특징:
   - 데이터가 정렬되어 있을 필요가 없음.
   - 가장 단순.
- 시간 복잡도: 최선- O(1), 최악- O(n), 평균- O(n)/ 공간 복잡도: O(1)

- 동작원리:
  1. 탐색 대상의 첫 번째 요소부터 시작.
  2. 각 요소를 타겟 값과 비교.
  3. 원하는 값을 찾으면 해당 위치(인덱스)를 반환.
  4. 끝까지 탐색했는데 값이 없으면 탐색 실패.

- 장점: 데이터 정렬 여부 상관없이 작동.
- 단점: 데이터 크기가 커질수록 탐색 시간이 길어짐.



#### 2. 이진 탐색
- 정렬된 데이터를 대상으로, 탐색 범위를 절반씩 줄여가며 값을 찾음.
- 특징: 정렬된 데이터에서만 사용 가능.
- 시간 복잡도: O(n log n)/ 공간 복잡도: O(1)

- 동작원리:
   1. 데이터의 중간값을 확인.
   2. 중간값과 타겟 값을 비교.
      - 타겟 값 < 중간 값: 탐색 범위를 중간값의 왼쪽 절반으로 줄임.
      - 타겟 값 > 중간 값: 탐색 범위를 중간값의 오른쪽 절반으로 줄임.
   3. 탐색 범위기ㅏ 1 이하가 될 때까지 위 과정을 반복.
   4. 값이 발견되면 해당 인덱스를 반환.

- 장점: 선형 탐색보다 훨씬 효율적.

- 단점: 데이터 삽입, 삭제 시 정렬을 유지하는 추가 작업 필요.


#### 3. 이진 탐색 변형 
- 이진 탐색을 기반으로, 특정 조건이나 목표에 맞게 작동.
- -특징: 정렬된 데이터에서만 사용 가능.
  
- 동작 원리:
  - 기본적으로 중간값을 기준으로 배열을 반으로 나누고, 그 값 기준으로 탐색 범위를 축소.
  - 특정 조건을 만족하는 값을 찾기 위해 추가적인 로직 포함.

- 장점: 값을 찾는 방법을 변형하여 다양한 상황에서 유용.

- 단점: 정렬된 데이터에서만 사용 가능. 

- 활용: 
  - 중복된 값 처리.
  - 특정 범위 내에 포함된 값들을 빠르게 찾는데 유용.
### 고급 탐색 알고리즘
#### 이진 검색 트리 (Binary Search Tree, BST) 기반 탐색
- 정의: 이진 트리의 일정으로 , 각 노드가 다음과 같은 특성을 가짐.
   - 왼쪽 서브트리의 모든 노드 값은 부모 노드 값보다 작다.
   - 오른쪽 서브트리의 모든 노드 값은 부모 노드 값보다 크다.
- 특징: 
    - 각 노드는 두 개 이하의 자식 노드를 가질 수 있다. 
    - 트리는 값의 삽입과 삭제에 따라 동적으로 변한다. 

- 동작 원리:
  - 탐색 (Search):
     - 루트 노드에서 시작하여, 찾고자 하는 값을 비교.
     - 찾고자 하는 값이 현재 노드보다 작으면 왼쪽 자식으로, 크면 오른쪽 자식으로 이동.
  - 삽입 (Insert):
     - 삽입할 값을 트리에 추가할 위치를 찾는다. 
     - 탐색 과정을 통해 적절한 자식 위치를 찾은 후, 그 자리에 값을 삽입.
  - 삭제 (Deletion):
     - 삭제할 노드를 찾는다.
     - 삭제할 노드가 자식 노드를 가지지 않으면 그냥 제거.
     - 자식 노드가 하나만 있으면 해당 자식을 부모와 연결.
     - 자식 노드가 두 개 있으면, 가장 오른쪽의 자식 노드 또는 가장 왼쪽의 자식 노드를 대체하여 삭제.

- 장점: 빠른 탐색이 가능하고 동적으로 데이터를 관리할 수 있다.
- 단점: 삽입이 계속해서 왼쪽 또는 오른쪽에만 일어나면 트리가 편향되면서 불균형 문제가 생길 수 있다.
- 활용: 검색 엔진, 사전 구현에서 활용됨.

#### 해시 기반 탐색
- 데이터를 특정한 키에 매핑하는 해시 함수를 사용하여, 데이터를 저장하고 검색하는 방법.
- 특징: 해시 기반 탐색은 O(1) 의 시간 복잡도를 가진다.

- 장점: 
  - 빠른 탐색이 가능하다.
  - 해시 테이블은 연속된 배열을 사용하여 데이터를 저장하므로, 메모리 접근 속도가 빠르다.

- 단점:
  - 해시 함수가 고유하지 않기 때문에 충돌이 발생할 수 있다.
  - 순차적 탐색이 불가능하므로, 정렬된 순서로 찾는 데는 적합하지 않다. 

- 활용:
  - 사전: 단어와 그 정의를 매핑하는 데 해시 테이블을 사용하여, 단어를 빠르게 찾을 수 있다.
  - 중복 검사: 대량의 데이터를 처리할 때, 해시 집합을 사용할 수 있다.

#### 트라이 기반 탐색
- 문자열 집합을 효율적으로 저장하고 탐색하기 위한 트리 기반 자료 구조에서 사용. 
- 특징: 문자열이 같은 접두사를 공유하면 동일한 경로를 따른다. 

- 동작 원리
  1. 삽입: 
    - 문자열의 각 문자를 트리의 노드로 삽입.
    - 기존의 경로가 존재하면 해당 경로를 따라가고, 없으면 새 노드를 추가.
    - 마지막 문자 노드애 단어의 끝 표시를 추가.
  2. 탐색:
    - 루트에서 시작하여 노드를 탐색.
    - 문자를 끝까지 따라갔을 때 단어의 끝 표시가 있으면 문자열 존재.
  3. 삭제:
    - 탐색 과정을 통해 문자열을 찾는다.
    - 삭제할 문자열이 끝나는 노드의 단어의 끝 표시를 제거한다.
    - 자식 노드가 없는 경우에만 불필요한 노드들을 제거한다. 

- 장점: 접두사 기반 탐색이 매우 빠르다.

- 단점: 트라이의 노드들은 많은 포인터를 가지므로 메모리 소비가 크다. 

### 탐색 알고리즘의 시간 복잡도 분석
- 탐색 알고리즘의 시간 복잡도는 데이터의 구조, 탐색 방식, 그리고 데이터 크기에 따라 달라진다.

1) 선형 탐색 (Linear Search)
   - 배열이나 리스트의 처음부터 끝까지 순차적으로 데이터를 찾는 방법.
   - 시간복잡도:
       - 최선: O(1)
       - 평균/최악: O(n)
2) 이진 탐색 (Binary Search)
   - 정렬된 배열에서 중간요소를 기준으로 탐색 범위를 줄여가며 탐색.
   - 시간 복잡도:
       - 최선: O(1)
       - 평균/최악: O(log n)
3) 해시 탐색 (Hash Search)
   - 해시 함수를 통해 데이터를 인덱스로 매핑하여 탐색. 
   - 시간 복잡도: 
       - 평균: O(1)
       - 최악: O(n)

## 재귀 및 분할 정복

### 재귀 (Recursion)
- 정의: 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법.
1) 기저조건 (Base Case)
  - 재귀 조건을 멈추는 조건 
2) 재귀 단계 (Recursive Step)
  - 함수가 자신을 호출하여 문제를 더 작은 하위 문제로 나누는 단계. 
- 예제:
<pre>
<code>// Phython 팩토리얼 
def factorial(n):
    if n == 0:  # 기저 조건
        return 1
    return n * factorial(n - 1)  # 재귀 단계
</code>
</pre>
#### 꼬리 재귀 (Tail Recursion)
- 함수가 자신을 호출할 때, 호출이 함수의 마지막 작업으로 이루어지는 재귀.
- 특징: 현재 함수의 스택 프레임을 재사용하므로 스택 오버플로우 위험이 줄어든다. 
- 조건:
   - 재귀 호출이 함수의 마지막 작업이어야 함. 
   - 현재 함수의 결과를 즉시 반환해야 함.
- 장점: 반복문을 재귀적으로 표현이 가능.
- 단점: 반복문보다 누적 변수 같은 추가 매개변수를 사용해야 하므로 코드가 복잡해질 가능성이 존재. 
- 활용: 수학 계산, 데이터 구조 탐색. 
#### 재귀와 반복  비교
|특징|재귀|반복|
|---|---|---|
|가독성|간결하고  직관적|복잡한 문제에서는 코드가 길어질 수 있음|
|메모리 사용|호출 스택 사용|추가 메모리 사용 없음|
|성능|호출 스택 관리로 인해 더 느릴 숭 있음|더 빠르고 효율적|
|오류 위험|스택 오버플로우 발생 가능|무한 루프 발생 가능|
|언어 지원|꼬리 재귀 최적화 여부에 따라 효율성이 다름|거의 모든 언어에서 기본 제공|

### 분할 정복 (Divide and Conquer
- 분할, 정복, 결합 과정을 통해 문제를 해결.
- 특징: 분할된 하위 문제는 독립적이므로 병렬 처리가 가능.
1) 분할 (Divide):
   - 주어진 문제를 여러 개의 작은 하위 문제로 나눈다.
2) 정복 (Conquer):
   - 하위 문제를 재귀적으로 해결.
   - 하위 문제가 충분히 작아지면 직접 해결.
3) 결합 (Combine):
   - 하위 문제의 결과를 결합하여 원래 문제의 해결책을 만든다. 

### 백트래킹 
- 가능한 해결책을 하나씩 시도하며, 더 이상 유효하지 않거나 불가능한 경우 되돌아가서 다른 가능성을 탐색하는 알고리즘 설계 기법.
- 특징: 주로 재귀 호출을 사용해 구현한다.

- 동작 원리:
  1. 가능한 선택을 하나씩 시도. 
  2. 선택이 유효한지 확인. 
  3. 더 이상 진행할 수 없으면 되돌아가며 다른 선택을 시도. 
  4. 해결책을 찾으면 종료.

- 장점: 잘못된 경로를 빠르게 배제.

- 단점: 모든 가능한 경로를 탐색하므로 시간 복잡도가 매우 클 수 있음.

#### N-Queens
- NxN 크기의 체스판에 N개의 퀸을 배치하는 문제.
- 각 퀸은 다른 퀸들과 같은 행, 열, 대각선에 놓일 수 없다.
- 문제 요구사항: 
    - 입력: N
    - 출력: NxN (체스판에 퀸을 배치할 수 있는 방법들)
#### Sudoku Solover
- 스도쿠는 9x9 크기의 격자에 1부터 9까지의 숫자를 채우는 퍼즐이다. 
- 알고리즘:
   1. 가능한 모든 숫자를 하나씩 시도하고 유효한 숫자만 진행.
   2. 현재 칸에 숫자를 배치한 후, 숫자가 유효한지 검사. 
   3. 모든 빈 칸이 채워지면 종료.
## 그리디 알고리즘 
- 현재 상황에서 가장 최선의 선택을 하는 방법을 사용하여 전체 문제를 해결.
- 특징: 각 문제에 대한 선택이 나중에 최적해로 이어질 것이라는 보장이 있어야 함.
 
- 동작 원리:
  1. 문제를 여러 개의 작은 부분으로 나눈다. 
  2. 각 부분에서 가장 좋은 선택을 하여 해결한다.
  3. 각 선택들을 합쳐 전체 문제에 대한 해결책을 구한다.

- 장점: 단순하고 직관적이며 다른 알고리즘보다 연산량이 적다. 

- 단점: 국소적 최적해만을 선택하므로 항상 전체 문제에 대한 전역 최적헤를 보장할 수 없다. 

- 그리디 알고리즘 예시:
 1) 동전 거스름돈 문제:
   - 주어진 동전의 종류로 특정 금액을 만들기 위한 최소 동전 수를 구하는 문제.
  
## 동적 계획법
- 문제를 작은 부분 문제로 나누어 해결한 후, 그 결과를 이용해 전체 문제의 해를 구하는 방법.
- 특징:
   - 동일한 부분 문제를 여러 번 계산해야 할 경우, 이전에 계산한 값을 저장해 두고, 그 값을 재사용하여 중복 계산을 방지.
   - 문제의 최적해가 부분 문제의 최적해로 구성. 

- 동작 원리:
  1. 문제를 작은 부분으로 나눈다.
  2. 부분 문제의 해를 저장한다.
  3. 저장된 부분 문제들의 해결 결과를 바탕으로 전체 문제의 최적해를 구한다. 

- 접근법:
  1. 상향식 접근: 
    - 작은 부분 문제부터 차례대로 풀어나가며 큰 문제를 해결.
  2. 하향식 접근:
    - 전체 문제를 먼저 해결하려고 시도하며, 필요한 부분 문제를 재귀적으로 풀어나가는 방식. 

- 장점:
 - 중복 계산 방지를 통해 문제 푸는 데 드는 시간 복잡도를 줄일 수 있다. 

- 단점:
 - 많은 부분 문제의 결과를 저장해야 하므로 메모리 사용량이 많아질 수 있다. 

- 문제 예시:
 1. 배낭 문제:
   - 주어진 아이템들을 배낭에 넣을 때, 배낭의 용량을 넘지 않도록 하면서 얻을 수 있는 최대 가치를 구하는 문제. 
   - 시간 복잡도: O(n×W), 여기서 n은 아이템의 개수, W는 배낭의 용량.
  
#### 메모이제이션 
- 하향식 접근 방식으로 재귀적으로 문제를 해결하면서 계산된 결과를 저장하여 중복 계산을 방지. 

#### 타뷸레이션 
- 상향식 접근 방식으로, 작은 부분 문제부터 차례대로 풀어나가며 결과를 테이블에 저장.
- 주로 반복문을 사용.

## 그래프 알고리즘
- 그래프란느 자료 구조를 기반으로 문제를 해결하는 알고리즘. 
### 탐색
#### 깊이 우선 탐색
#### 너비 우선 탐색
### 최단 경로
#### 다익스트라 알고리즘
#### 벨만-포드 알고리즘
#### 플로이드-워셜 알고리즘
### 네트워크 플로우
- 정의: 네트워크 내에서 흐르는 양을 최적화하거나 특정 조건을 만족하는 방법을 찾는 문제. 
#### 에드몬드-카프 알고리즘
- 정의: 네트워크에서 흐를 수 있는 최대 양을 계산.
- 동작 원리:
  - BFS를 사용하여 최단 경로를 찾아가며 흐름을 증가시킴.
  - 최단 경로를 선택하여 빠르게 최대 유량을 구함. 
#### 푸시-재명칭 알고리즘
- 정의: 각 정점에 대해 흐름을 푸시하고, 정점의 높이를 조정하여 흐름을 계산.
- 동작 원리:
  - 흐름을 정점 간에 푸시.
  - 흐름을 이동시키지 못하면 정점의 높이를 조정.
  - 흐름을 점진적으로 맞춰감.
### 위상 정렬
## 문자열 알고리즘
### 문자열 검색
- 정의: 주어진 텍스트 내에서 특정 패턴을 찾아내는 알고리즘.  
#### KMP 알고리즘
- 정의: 패턴을 텍스트에서 효율적으로 찾음.
- 동작 원리:
  - 부분 일치 테이블을 이용하여 일치한 부분을 재사용하여 검색 속도를 향상시킨다.
#### 라빈-카프 알고리즘
- 정의: 해시 기반의 문자열 검색 알고리즘. 
- 동작 원리:
  - 주어진 패턴과 텍스트를 해시 함수를 사용하여 비교. 
  - 텍스트의 각 부분에 대해 해시 값을 계산하고, 패턴의 해시 값과 비교하여 일치하는지 확인.
  - 일지하면 문자 단위 비교를 진행.
 
### 접미사 배열 및 트라이
#### 접미사 배열
- 정의: 주어진 문자열의 모든 접미사들을 사전순으로 정렬한 배열.
- 시간 복잡도: 최적화된 알고리즘을 사용하면 O(n log n). 
#### 접미사 트리 
- 주어진 문자열의 모든 접미사들을 트리 구조로 표현한 자료구조. 
- 트라이와 유사하지만, 접미사 트리는 모든 접미사를 하나의 트리 구조로 통합하여 표현 가능.
- 특징: 리프 노드는 각 접미사의 시작 위치를 나타내고 내부 노드는 공통된 접두사를 나타낸다. 
### 롤링 해시 및 Z-알고리즘
- 정의: 문자열을 해시 값으로 변환하여 부분 문자열 검색을 처리.
- 동작 원리:
   1. 첫 번째 부분 문자열의 해시 값을 계산.
   2. 한 문자가 추가되거나 제거될 때마다 새로운 해시 값을 상수 시간에 계산.
   3. 모듈러 연산을 사용하여 해시 값의 범위를 조정. 

## 수학 및 수치 알고리즘
### 기초 수학 알고리즘
#### 유클리드 호제법
- 정의: 나머지를 반복적으로 계산하면서 두 정수의 최대공약수를 찾는 방법.
- 시간 복잡도: O(og(min(a,b)))
- 동작 원리:
  - 두 정수 a와 b가 주어졌을 때:
     - GCD(a,b)=GCD(a%b).
  - 나머지가 0이 될 때의 b의 값이 GCD(a,b).

#### 소수 판별
- 동작 원리:
   1. 입력 값 n이 소수인지 확인:
   2. 나누어 떨어지는 수가 없으면 소수.
#### 에라토스테네스의 체
- 정의: 소수가 아닌 수를 반복적으로 제거하면서 남은 수를 소수로 분류하는 것을 통해 범위 내 소수를 찾음.
- 동작 원리:
  - 1. 2부터 n까지의 정수를 나열.
  - 2. 가장 작은 소수 2를 선택하고, 2의 배수를 제거.
  - 3. 남은 수 중 가장 작은 수를 선택하고, 그 배수를 제거.
  - 4. 더 이상 반복할 수 없을 때까지 2번과 3번 과정을 반복. 

### 모듈러 연산
- 정의: 두 정수를 나눗셈한 후 나머지를 구하는 연산.


- 장점:
   - 큰 수를 다룰 때 값이 제한되어 효율적인 계산이 가능.
   - 계산 결과가 m을 주기로 반복되므로 규칙성이 있음.
- 단점: 
   - 음수에 대한 모듈러 연산 결과가 시스템 구현에 따라 다를 수 있음. 
  
#### 빠른 거듭제곱
- 거듭제곱을 직접 계산하는 대신, 거듭제곱을 분할하여 점차적으로 계산. 
- 장점: 
   - 일반적인 거듭제곱 계산에서는 O(b) 시간이 걸리지만, 빠른 거듭제곱은 O(logb)로 계산이 가능.
- 단점: 
   - 이진법을 사용해야 하므로 구현이 약간 더 복잡할 수 있음. 
#### 중국인의 나머지 정리 (Chinese Remainder Theorem, CRT)
- 정의: 서로소인 두 개 이상의 정수들로 나뉘는 동시 합동식을 해결하는 정리. 
- 장점:
   - 큰 숫자의 계산을 여러 작은 모둘러 연산으로 나누어 처리할 수 있다. 
   - 여러 모듈러 식을 한 번에 해결할 수 있다. 
- 단점: 
  - 서로소 조건이 필수이다. 
  - M의 크기가 매우 커질 경우, 계산 과정에서 정수 오버플로우가 발생 가능. 
- 활용: 
   1. 암호학: RSA암호화에서 큰 숫자의 모듈러 연산을 최적화하기 위해 CRT를 사용.
   2. 컴퓨터 과학: 큰 계산을 작은 모듈러 연산으로 나누어 병렬적으로 처리. 
### 행렬 연산
- 정의: 행렬을 대상으로 수행되는 다양한 연산. 
- 기본 연산: 덧셈, 뺄셈, 스칼라 곱
- 고급 연산: 곱셈, 전치, 역행렬, 행렬식 계산, 고유값/고유벡터
- 응용 연산: 행렬 분해, 변환
- 장점: 
  - 다차원 데이터를 효율적으로 나타내고 처리할 수 있다. 
  - 대부분의 행렬 연산은 벡터화 및 병렬 처리가 가능하여 계산 성능을 높일 수 있다. 
- 단점: 
   - 행렬식이 0에 가까울 경우 역행렬 계산 등에서 오차가 커질 수 있다.
   - 큰 행렬의 곱셈이나 역행렬 계산은 매우 계산 집약적이라 계산 복잡도가 증가. 
- 활용: 
   - 컴퓨터 그래픽스: 3D 모델의 변환에 행렬을 사용.
   - 기계 학습 및 딥러닝: 행렬은 뉴럴 네트워크의 가중치 및 활성화 계산의 기반. 
## 조합 및 확률
### 조합론 
- 유한 집합의 배열, 선택, 분할, 구성 방법과 같은 문제를 다룬다.
- 특징: 
   - 다양한 상황에서 가능한 배열이나 선택의 수를 계산하는 것이 조합론의 핵심.
   - 조합론은 주로 유한 개수의 집합을 다룬다.
#### 순열 및 조합
(1) 순열 (Permutation)
- 정의: 일정한 순서를 고려하여 주어진 원소들을 나열.
- 순서를 중시함. 
- 이미지 넣기 
- 활용: 암호학(비밀번호 생성, 키 생성)

(2) 조합 (Combination)
- 정의: 순서를 고려하지 않고 주어진 원소 중 일부를 선택하는 방법.
- 이미지 넣기 
- 활용: 통계학(표본 추출, 확률 계산)

#### 비트마스크를 활용한 부분집합 생성
- 정의: 이진수의 각 비트를 활용해 집합의 포함 여부를 표현하는 방법.
- 원리:
   1. 이진수로 부분 집합 표현:
      - 집합의 크기가 n일 때, 2^n 개의 부분 집합이 존재.
      - 각 원소가 부분 집합에 포함되는지 여부를 0(포함되지 않음), 1(포함됨)로 표현.
   2. 비트마스크와 인덱스 매핑:
      - 비트마스크의 각 비트는 집합의 원소에 대응.
      - i번째 비트가 1이면 S[i]가 포함되고, 0이면 포함되지 않음.
<pre>
<code>//python
def generate_subsets(elements):
    n = len(elements)
    subsets = []
    
    for mask in range(1 << n):  # 0부터 2^n - 1까지 반복
        subset = []
        for i in range(n):  # 각 비트를 확인
            if mask & (1 << i):  # i번째 비트가 1인지 확인
                subset.append(elements[i])
        subsets.append(subset)
    
    return subsets

# Example usage
elements = ['a', 'b', 'c']
subsets = generate_subsets(elements)
for subset in subsets:
    print(subset)
</code>
</pre>
- 장점: 배열이나 리스트 대신 비트연산을 사용하여 저장 공간 절약.
- 단점: n이 클 경우 시간 및 메모리 부담 증가. 
- 활용: 조합론 문제.
-c언어로 구현하기 

### 확률 기반 알고리즘
- 정의: 무작위를 사용하여 문제를 해결하는 알고리즘으로, 계산 과정에서 난수를 활용하여 결과 도출. 
- 특징:
   - 무작위성
   - 최적의 해를 보장하지 않지만, 효율적으로 근사값을 찾음. 
   - 시간 복잡도가 낮거나 일정한 반복 횟수를 통해 빠르게 근사값을 구함. 
#### 몬테카를로 시뮬레이션
- 정의: 난수를 기반으로 실험을 반복적으로 수행하여 복잡한 문제를 근사적으로 해결. 
- 동작 원리:
   1. 문제 정의
   2. 입력값을 나타내는 난수 생성.
   3. 난수를 입력으로 사용해 계산이나 실험을 반복적으로 수행.
   4. 반복 실험 결과를 기반으로 평균, 분산 등의 통계량을 계산하여 결과를 도출. 
- 장점: 
   - 수학적으로 풀기 어려운 문제를 확률을 이용해 근사적으로 해결. 
- 단점:
   - 반복 횟수가 적으면 정확도가 떨어질 수 있으며, 수렴 속도가 느리다. 
   - 난수 생성기의 품질이 결과의 신뢰성에 영향을 미친다. 
- 활용: 금융(투자 위험 분석 및 수익률 예측), 의학(약물 효과와 부작용 확률 예측) 
#### 랜덤화 알고리즘
- 정의: 무작위를 활용하여 문제를 해결하는 알고리즘.
- 동작 원리: 
    1. 난수 생성.
    2. 확률적 경로 선택하고 이를 기반으로 계산을 진행.
    3. 반복적인 실행을 통해 알고리즘의 정확도를 높일 수 있음. 
- 장점: 일부 알고리즘은 정확한 답을 찾지 않더라도 결과의 확률적 정확도를 보장. 
- 단점: 동일한 입력에 대해서도 실행마다 다른 결과를 얻을 수 있음. 
## 기타 알고리즘
### 슬라이딩 윈도우
- 정의: 배열이나 리스트 같은 순차 자료 구조에서 고정 크기 또는 가변 크기의 윈도우를 이동시키며 문제를 해결.
- 특징:
   - 한 번의 순회로 문제를 해결할 수 있도록 윈도우를 좌우로 이동.
   - 이전 윈도우의 결과를 재활용하여 중복 계산을 줄임.
- 동작 원리: 
   1. 첫 번째 윈도우의 크기 k만큼 처리.
   2. 윈도우의 시작과 끝을 한 칸씩 이동.
   3. 새롭게 포함된 요소를 추가하고, 제외된 요소를 제거.
   4. 각 단계에서 결과를 저장하거나 갱신.
- 장점: 한 번의 순회(O(n))로 문제를 해결하는 경우가 많아 중복 계산을 줄인다.
- 단점: 고정 크기 윈도우는 간단하지만 가변 크기 윈도우 문제에서는 로직이 복잡해질 수 있다.
- 활용: 데이터 스트림 처리, 배열 및 문자열 문제.
### 분할-정복적 접근법
### 유니온-파인드
- 정의: 서로소 집합을 표현하고 조작하기 위한 자료구조.
- 동작 원리:
   1. Find (찾기): 
       - 특정 원소가 속한 집합의 대표 원소를 찾는다.
       - 경로 압축 기법을 사용해 탐색 경로를 최적화.
   2. Union (합치기): 
       - 두 집합을 하나로 합친다.
       - 랭크 또는 사이즈 기반으로 합치기 기법을 사용헤 트리의 높이를 최소화한다. 
- 장점: 
   - 경로 압축과 랭크 기반 유니온을 사용하면 거의 상수 시간에 가까운 성능(O(α(n)))으로 Find와 Union을 수행.
   - 비교적 적은 메모리로 대규모 데이터 처리 가능.
- 단점: 
   - 데이터 구조 초기화가 필요하다.
   - 연결 관계를 기반으로 하는 문제에는 적합하지만, 일반적인 트리나 그래프 탐색에는 부적합. 
- 활용: 네트워크 분석, 사이클 검출.
### 두 포인터 기법
- 정의: 선형 데이터 구조에서 두 개의 포인터를 동시에 조작하여 특정 조건을 만족하는 부분 집합이나 값을 찾는 알고리즘 설계 기법. 
- 동작 원리:
   1. 두 포인터를 배열의 시작점과 끝점, 또는 시작점과 특정 간격으로 설정하여 초기화.
   2. 두 포인터가 만족해야 할 특정 조건을 확인. 
   3. 조건에 따라 포인터를 조작하여 문제 해결.
   4. 두 포인터가 교차하거나 탐색 범위를 벗어나면 종료.
- 장점: 
   - 대부분의 문제를 O(n) 또는 O(n log n) 시간 복잡도로 해결 가능.
   - 이중 루츠와 같은 복잡한 구조 대신 간단한 포인터 이동으로 구현 가능. 
- 단점: 
   - 선형 데이터 구조에서만 사용 가능.
- 활용: 배열 내 두 숫자의 합 구하기, 중복 원소 제거하기.
### 스위핑 기법
- 정의: 정렬과 함께 선형 또는 순차 탐색을 통해 문제 해결.
- 동작 원리:
   1. 문제의 주요 변경점을 이벤트로 정의.
   2. 이벤트를 기준에 따라 정렬.
   3. 상태를 나타내는 변수를 초기화.
   4. 정렬된 이벤트를 순차적으로 처리하면서 상태를 업데이트한다. 
- 장점:
   - 정렬 후 선형 탐색을 사용해 O(n log n) 시간 복잡도로 문제 해결 가능.
   - 이벤트를 정렬하고 순차 처리하는 구조로 구현이 비교적 간단.
- 단점: 
   - 정렬 과정에서 추가적인 시간이 소요됨.
   - 이벤트 처리 중 상태 업데이트 및 조건 관리가 복잡할 수 있다. 
- 활용: 선분 교차 문제.

## 알고리즘 분석
### 시간 복잡도 
- 정의: 알고리즘이 실행되는 동안 걸리는 시간을 입력 크기 n에 대한 함수로 표현한 것. 
- 시간 복잡도 표현 방식:
   1. 빅오 표기법 (O)
      - 최악의 경우를 나타냄.
      - 알고리즘의 성능 상한선을 표현.
   2. 빅오메가 표기법 (Ω)
      - 최선의 경우를 나타냄.
      - 알고리즘의 성능 하한선을 표현.
   3. 빅세타 표기법 (Θ)
      - 평균적인 경우를 나타냄.
      - 입력 크기 n에 따른 정확한 성능을 나타냄.
#### 시간 복잡도 분석 기법

### 공간 복잡도 
- 정의: 알고리즘이 실행되는 동안 필요로 하는 메모리 양을 입력 크기 n에 대한 함수로 나타낸 것. 
- 빅오 표기법으로 표현.
- 공간 복잡도 분석의 주요 요소:
   1. 고정 공간 (Fixed Part)
      - 입력 크기에 상관없이 항상 일정하게 요구되는 공간.
      - 예: 변수, 상수.
   2. 가변 공간 (Variable Part)
      - 입력 크기에 따라 달라지는 공간. 
      - 예: 입력 데이터 저장, 동적 메모리 할당.
### 최선, 평균, 최악의 경우 분석 
#### 최선의 경우 
- 알고리즘이 가장 효율적으로 작업을 수행하는 입력 상황.
- 시간 복잡도가 최소가 되는 경우를 분석. 
#### 평균적인 경우
- 모든 가능한 입력에 대해 알고리즘이 수행하는 작업의 평균값.
- 가능한 모든 입력에 대해 알고리즘이 수행하는 작업의 평균을 계산.
#### 최악의 경우 
- 알고리즘이 가장 비효율적으로 작업을 수행하는 입력 상황. 
- 시간 복잡도가 최대가 되는 경우를 분석.
